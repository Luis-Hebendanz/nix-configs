
"*****************************************************************************
"" Functions
"*****************************************************************************

function! GetBufferList()
    redir =>buflist
    silent! ls!
    redir END
    return buflist
endfunction

function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
        if bufwinnr(bufnum) != -1
            exec(a:pfx.'close')
            return
        endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open')
    if winnr() != winnr
        wincmd p
    endif
endfunction


"*****************************************************************************
"" Basic Setup
"*****************************************************************************"
" General
let no_buffers_menu=1
syntax on
set ruler
set number
set mousemodel=popup
set t_Co=256
set guioptions=egmrti
set gfn=Monospace\ 10

" TODO: Testing if this works against automatically setting paste mode
" Issue: https://github.com/neovim/neovim/issues/7994
au InsertLeave * set nopaste


" undofile - This allows you to use undos after exiting and restarting
" This, like swap and backups, uses .vim-undo first, then ~/.vim/undo
" :help undo-persistence
if exists("+undofile")
    if isdirectory($HOME . '/.vim/undo') == 0
        :silent !mkdir -p ~/.vim/undo > /dev/null 2>&1
    endif
    set undodir=./.vim-undo//
    set undodir+=~/.vim/undo//
    set undofile
endif

" Encoding
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8
set bomb
set binary

" Fix backspace indent
set backspace=indent,eol,start

" Tabs. May be overriten by autocmd rules
set tabstop=4
set softtabstop=0
set shiftwidth=4
set expandtab

" Map leader to ,
let mapleader=','

" Required for operations modifying multiple buffers like rename.
set hidden

" Searching
set hlsearch
set incsearch
set ignorecase
set smartcase

" Directories for swp files
set nobackup
set noswapfile

set fileformats=unix,dos,mac

" File overview
set wildmode=list:longest,list:full
set wildignore+=*.o,*.obj,.git,*.rbc,*.pyc,__pycache__

" Shell to emulate
if exists('$SHELL')
    set shell=$SHELL
else
    set shell=/bin/bash
endif

" Set color scheme
colorscheme molokai

"Show always Status bar
set laststatus=2

" Use modeline overrides
set modeline
set modelines=10

" Set terminal title
set title
set titleold="Terminal"
set titlestring=%F

" search will center on the line it's found in.
nnoremap n nzzzv
nnoremap N Nzzzv



"*****************************************************************************
"" Abbreviations
"*****************************************************************************
" no one is really happy until you have this shortcuts
cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qall! qall!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qall qall

" open terminal emulation
nnoremap <silent> <leader>sh :terminal<CR>:startinsert<CR>

"*****************************************************************************
"" Autocmd Rules
"*****************************************************************************
"" The PC is fast enough, do syntax highlight syncing from start unless 200 lines
augroup vimrc-sync-fromstart
    autocmd!
    autocmd BufEnter * :syntax sync maxlines=200
augroup END

" Nasm filetype
augroup nasm
    autocmd!
    autocmd BufRead,BufNewFile *.nasm set ft=nasm
augroup END

" Binary filetype
augroup Binary
    au!
    au BufReadPre  *.bin,*.exe,*.elf let &bin=1
    au BufReadPost *.bin,*.exe,*.elf if &bin | %!xxd
    au BufReadPost *.bin,*.exe,*.elf set ft=xxd | endif
    au BufWritePre *.bin,*.exe,*.elf if &bin | %!xxd -r
    au BufWritePre *.bin,*.exe,*.elf endif
    au BufWritePost *.bin,*.exe,*.elf if &bin | %!xxd
    au BufWritePost *.bin,*.exe,*.elf set nomod | endif
augroup END

" Binary filetype
augroup fasm
    au!
    au BufReadPost *.fasm set ft=fasm
augroup END


"" Remember cursor position
augroup vimrc-remember-cursor-position
    autocmd!
    autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
augroup END

" Close vim if there are no buffers with a file
autocmd BufDelete * if len(filter(range(1, bufnr('$')), '! empty(bufname(v:val)) && buflisted(v:val)')) == 1 | quit | endif

"" txt
" augroup vimrc-wrapping
"   autocmd!
"   autocmd BufRead,BufNewFile *.txt call s:setupWrapping()
" augroup END

"" make/cmake
augroup vimrc-make-cmake
    autocmd!
    autocmd FileType make setlocal noexpandtab
    autocmd BufNewFile,BufRead CMakeLists.txt setlocal filetype=cmake
augroup END

set autoread

"*****************************************************************************
"" Mappings
"*****************************************************************************

" Split
noremap <Leader>h :<C-u>split<CR>
noremap <Leader>v :<C-u>vsplit<CR>

" Git
noremap <Leader>ga :Gwrite<CR>
noremap <Leader>gc :Gcommit<CR>
noremap <Leader>gsh :Gpush<CR>
noremap <Leader>gll :Gpull<CR>
noremap <Leader>gs :Gstatus<CR>
noremap <Leader>gb :Gblame<CR>
noremap <Leader>gd :Gvdiff<CR>
noremap <Leader>gr :Gremove<CR>

" Tabs
nnoremap <Tab> :bnext<CR>
nnoremap <S-Tab> :bprevious<CR>
"nnoremap <silent> <S-t> :tabnew<CR>

" Set working directory
nnoremap <leader>. :lcd %:p:h<CR>

" Opens an edit command with the path of the currently edited file filled in
"noremap <Leader>e :e <C-R>=expand("%:p:h") . "/" <CR>

" Opens a tab edit command with the path of the currently edited file filled
" noremap <Leader>te :tabe <C-R>=expand("%:p:h") . "/" <CR>
noremap <Leader>te :edit <C-R>=expand("%:p:h") . "/" <CR>

" Tagbar
nmap <silent> <F3> :TagbarToggle<CR>
let g:tagbar_autofocus = 1

" Copy/Paste/Cut
set clipboard+=unnamedplus


noremap YY "+y<CR>
noremap <leader>p "+gP<CR>
noremap XX "+x<CR>

" Enable mouse for vim
set mouse=a

" Buffer nav
noremap <leader>z :bp<CR>
noremap <leader>q :bp<CR>
noremap <leader>x :bn<CR>
noremap <leader>w :bn<CR>

" Close buffer
noremap <leader>c :bd<CR>

" Clean search (highlight)
nnoremap <silent> <leader><space> :noh<cr>

" Switching windows
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l
noremap <C-h> <C-w>h

" Vmap for maintain Visual Mode after shifting > and <
vmap < <gv
vmap > >gv

" Move visual block
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

" Open current line on GitHub
nnoremap <Leader>o :.Gbrowse<CR>


" Save on strg+s if not in paste mode
nmap <c-s> :w<CR>
vmap <c-s> <Esc><c-s>gv
imap <c-s> <Esc><c-s>

" Close buffer on strg+q in normal mode
nnoremap <c-q> :bd<cr>

" Strg+d to replace word under cursor
nnoremap <c-d> :%s/\<<C-r><C-w>\>//g<Left><Left>

" Strg+f ro find word under cursor
nnoremap <c-f> :/<C-r><C-w><Left><Left>

" Remove unneccessary spaces
nnoremap <silent> <F5> :let _s=@/ <Bar> :%s/\s\+$//e <Bar> :let @/=_s <Bar> :nohl <Bar> :unlet _s <CR>

" Reindent whole file with F6
map <F6> mzgg=G`z

" Toggle location list
nmap <silent> <F4> :call ToggleList("Quickfix List", 'c')<CR>

" Replacing text in visual mode doesn't copy it anymore
xmap p <Plug>ReplaceWithRegisterVisual
xmap <MiddleMouse> <Plug>ReplaceWithRegisterVisual

"" Opens an edit command with the path of the currently edited file filled in
noremap <Leader>e :e <C-R>=expand("%:p:h") . "/" <CR>

" Use tab for navigatin in autocompletion window
" use <tab> for trigger completion and navigate to the next complete item
function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~ '\s'
endfunction

inoremap <silent><expr> <Tab>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<Tab>" :
      \ coc#refresh()

inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"


"*****************************************************************************
"" Plugin settings
"*****************************************************************************

" vim-airline
set statusline+=%{fugitive#statusline()}
let g:airline_theme = 'powerlineish'
let g:airline#extensions#syntastic#enabled = 1
let g:airline#extensions#branch#enabled = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tagbar#enabled = 1
let g:airline#extensions#coc#enabled = 1
" Show just the filename
let g:airline#extensions#tabline#fnamemod = ':t'
let g:airline_skip_empty_sections = 1

" Use K to show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Highlight symbol under cursor on CursorHold
autocmd CursorHold * silent call CocActionAsync('highlight')

" Code jumping
nmap <silent> <leader>d <Plug>(coc-definition)
nmap <silent> <leader>t <Plug>(coc-type-definition)
nmap <silent> <leader>i <Plug>(coc-implementation)
nmap <silent> <leader>r <Plug>(coc-references)

" Code format selected region
xmap <leader>f  <Plug>(coc-format-selected)
nmap <leader>f  <Plug>(coc-format-selected)

" Autofix problem of current line
nmap <leader>af  <Plug>(coc-fix-current)

"*****************************************************************************
"" Shortcuts overview
"*****************************************************************************
" Shortcuts overview
" F3  --> Function overview
" F4  --> Toggle error bar

" F5  --> Remove trailing whitespaces
" F6  --> Reindent whole file
" F7  --> Format and lint file
" ,i  --> Information about function
" ,d  --> Jump to definition
" ,r  --> Rename in all occurences
" ,r  --> Find references of function/variable
" ,f  --> Code format selected region
" ,af --> Autofix problem of current line
" K   --> Show documentation
" ,e  --> Change current file
" ,te --> Open file in new tab
" u   --> Undo
" strg+r --> Redo
" strg+f --> Find current selected word
" strg+d --> Replace current selected word
" strg+s --> Save file
" strg+q --> Close current file
" space+, --> Stop highlighting words after search

